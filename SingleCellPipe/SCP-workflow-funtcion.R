Check_srtList <- function(srtList, normalization_method,
                          HVF_source = "separate", nHVF = 3000, hvf = NULL,
                          exogenous_genes = NULL, ...) {
  cat(paste0("[", Sys.time(), "]", " Checking srtList... ...\n"))
  require(Seurat)
  require(sctransform)
  require(glmGamPoi)

  if (class(srtList) != "list" | any(sapply(srtList, class) != "Seurat")) {
    stop("'srtList' is not a list of Seurat object.",
      call. = FALSE
    )
  }
  if (!normalization_method %in% c("logCPM", "SCT")) {
    stop("'normalization_method' must be one of: 'logCPM','SCT'",
      call. = FALSE
    )
  }
  if (!HVF_source %in% c("global", "separate")) {
    stop("'HVF_source' must be one of: 'global','separate'",
      call. = FALSE
    )
  }

  genelist <- lapply(srtList, function(x) {
    sort(rownames(GetAssayData(x, slot = "counts", assay = "RNA")))
  })
  if (length(unique(genelist)) != 1) {
    warning("'srtList' have different feature names! Will subset the common features for analysis!",
      call. = FALSE
    )
    cf <- lapply(srtList, rownames) %>% Reduce(intersect, .)
    for (i in 1:length(srtList)) {
      srtList[[i]] <- subset(srtList[[i]], features = cf)
    }
  }

  for (i in 1:length(srtList)) {
    if (!"RNA" %in% Seurat::Assays(srtList[[i]])) {
      stop(paste("srtList", i, "does not contain 'RNA' assay."),
        call. = FALSE
      )
    }
    DefaultAssay(srtList[[i]]) <- "RNA"
    if (identical(
      x = GetAssayData(srtList[[i]], slot = "counts"),
      y = GetAssayData(srtList[[i]], slot = "data")
    )) {
      cat("Perform NormalizeData(logCPM) on the data",i,"of the srtList...\n")
      srtList[[i]] <- NormalizeData(object = srtList[[i]], normalization.method = "LogNormalize", verbose = FALSE)
    }
    if (!"vst.variance.standardized" %in% colnames(srtList[[i]]@assays$RNA@meta.features)) {
      cat("Perform FindVariableFeatures on the data",i,"of the srtList...\n")
      srtList[[i]] <- FindVariableFeatures(srtList[[i]], verbose = FALSE)
    }
    m <- GetAssayData(srtList[[i]], slot = "counts")
    gene_keep <- rownames(m)[Matrix::rowSums(m >= 1) >= 5]
    VariableFeatures(srtList[[i]]) <- srtList[[i]]@assays$RNA@meta.features %>%
      filter(vst.variance.standardized > 1 &
        (!rownames(.) %in% exogenous_genes) &
        rownames(.) %in% gene_keep) %>%
      dplyr::arrange(desc(vst.variance.standardized)) %>%
      rownames(.) %>%
      head(n = nHVF)
    DefaultAssay(srtList[[i]]) <- "RNA"

    if (normalization_method %in% c("SCT")) {
      if (!"SCT" %in% Seurat::Assays(srtList[[i]])) {
        cat("Perform SCTransform on the data",i,"of the srtList...\n")
        srtList[[i]] <- SCTransform(
          object = srtList[[i]],
          method = "glmGamPoi",
          variable.features.n = nHVF,
          return.only.var.genes = FALSE,
          min_cells = 5,
          assay = "RNA",
          verbose = FALSE
        )
      } else {
        DefaultAssay(srtList[[i]]) <- "SCT"
      }
      if (!"residual_variance" %in% colnames(srtList[[i]]@assays$SCT@meta.features)) {
        feature.attr <- SCTResults(object = srtList[[i]], slot = "feature.attributes")
        nfeatures <- min(nHVF, nrow(x = feature.attr))
        top.features <- rownames(x = feature.attr)[order(feature.attr$residual_variance,
          decreasing = TRUE
        )[1:nHVF]]
        VariableFeatures(object = srtList[[i]]) <- top.features
        srtList[[i]]@assays$SCT@meta.features <- feature.attr
      }
      m <- GetAssayData(srtList[[i]], slot = "counts")
      gene_keep <- rownames(m)[Matrix::rowSums(m >= 1) >= 5]
      VariableFeatures(srtList[[i]]) <- srtList[[i]]@assays$SCT@meta.features %>%
        filter((!rownames(.) %in% exogenous_genes) &
          rownames(.) %in% gene_keep) %>%
        dplyr::arrange(desc(residual_variance)) %>%
        rownames(.) %>%
        head(n = nHVF)
    }
  }

  if (is.null(hvf)) {
    if (HVF_source == "global") {
      cat("Perform global HVF calculation on the merged datasets from the srtList...\n")
      gene_common <- lapply(srtList, function(x) {
        m <- GetAssayData(x, slot = "counts")
        gene_keep <- rownames(m)[Matrix::rowSums(m >= 1) >= 5 * length(srtList)]
        return(gene_keep)
      }) %>% Reduce(intersect, .)
      srtMerge <- Reduce(function(x, y) merge(x, y), srtList)
      hvf <- FindVariableFeatures(srtMerge, verbose = FALSE) %>%
        HVFInfo(.) %>%
        filter(vst.variance.standardized > 1 &
          (!rownames(.) %in% exogenous_genes) &
          rownames(.) %in% gene_common) %>%
        dplyr::arrange(desc(vst.variance.standardized)) %>%
        rownames(.) %>%
        head(n = nHVF)
    }
    if (HVF_source == "separate") {
      cat("Perform separate HVF calculation with SelectIntegrationFeatures from the existed HVF in srtList...\n")
      hvf <- SelectIntegrationFeatures(object.list = srtList, nfeatures = nHVF, verbose = FALSE)
    }
  } else {
    cf <- lapply(srtList, function(x) {
      rownames(GetAssayData(x, slot = "counts"))
    }) %>% Reduce(intersect, .)
    hvf <- hvf[hvf %in% cf]
  }

  if (normalization_method %in% c("SCT")) {
    srtList <- PrepSCTIntegration(object.list = srtList, anchor.features = hvf, verbose = FALSE)
  }
  cat(paste0("[", Sys.time(), "]", " Finished checking.\n"))

  return(list(
    srtList = srtList,
    hvf = hvf
  ))
}

Check_srtMerge <- function(srtMerge, normalization_method, batch,
                           HVF_source = "separate", nHVF = 3000, hvf = NULL,
                           exogenous_genes = NULL, ...) {
  if (class(srtMerge) != "Seurat") {
    stop("'srtMerge' is not a Seurat object.",
      call. = FALSE
    )
  }
  if (length(batch) != 1) {
    stop("batch must be a vector to specify the batch column in srtMerge object!",
      call. = FALSE
    )
  }
  if (!batch %in% colnames(srtMerge@meta.data)) {
    stop(paste0("No batch column('", batch, "') found in the srtMerge object!"),
      call. = FALSE
    )
  }
  cat("Spliting srtMerge into srtList... ...\n")
  srtList <- SplitObject(object = srtMerge, split.by = batch)

  checked <- Check_srtList(srtList,
    normalization_method = normalization_method,
    HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
    exogenous_genes = exogenous_genes
  )
  srtList <- checked[["srtList"]]
  hvf <- checked[["hvf"]]
  srtMerge <- Reduce(function(x, y) merge(x, y), srtList)
  VariableFeatures(srtMerge) <- hvf

  return(list(
    srtMerge = srtMerge,
    hvf = hvf
  ))
}

Check_srtIntegrated <- function(srtIntegrated, hvf, batch, ...) {
  raw_DefaultAssay <- DefaultAssay(object = srtIntegrated)

  DefaultAssay(object = srtIntegrated) <- "RNA"
  if (identical(
    x = GetAssayData(srtIntegrated, slot = "counts"),
    y = GetAssayData(srtIntegrated, slot = "data")
  )) {
    srtIntegrated <- NormalizeData(object = srtIntegrated)
  }
  if (length(VariableFeatures(srtIntegrated)) == 0) {
    hvf <- hvf[hvf %in% rownames(GetAssayData(srtIntegrated, slot = "counts"))]
    VariableFeatures(srtIntegrated) <- hvf
  }
  if (nrow(GetAssayData(srtIntegrated, slot = "scale.data")) != nrow(GetAssayData(srtIntegrated, slot = "data"))) {
    srtIntegrated <- ScaleData(object = srtIntegrated, features = rownames(srtIntegrated))
  }

  DefaultAssay(object = srtIntegrated) <- raw_DefaultAssay
  srtIntegrated@project.name <- paste0(unique(srtIntegrated[[batch, drop = TRUE]]), collapse = ",")
  srtIntegrated[[batch]] <- factor(srtIntegrated[[batch, drop = TRUE]],
    levels = unique(srtIntegrated[[batch, drop = TRUE]])
  )
  return(srtIntegrated)
}

CC_GenePrefetch <- function(species) {
  if (species == "Homo_sapiens") {
    cc_S_genes <- Seurat::cc.genes.updated.2019$s.genes
    cc_G2M_genes <- Seurat::cc.genes.updated.2019$g2m.genes
  } else {
    species_split <- unlist(strsplit(species, split = "_"))
    species_homolog <- paste0(tolower(substring(species_split[1], 1, 1)), species_split[2], "_homolog_associated_gene_name")

    archives <- listEnsemblArchives()
    # web <- read_html(httr::RETRY("GET", "http://www.ensembl.org/info/website/archives/index.html?redirect=no", times = 1000, timeout(1000)))
    # urls <- web %>% html_nodes("ul") %>% html_nodes("strong") %>% html_nodes("a") %>% html_attr("href")
    # version <- web %>% html_nodes("ul") %>% html_nodes("strong") %>% html_nodes("a") %>% html_text(trim = TRUE) %>%
    #   gsub(pattern = "(Ensembl )|(:.*)",replacement = "",x = .,perl = T)
    # archives <- data.frame(version=version,url=urls,stringsAsFactors = F)
    url <- archives[which(archives$version == Ensembl_version), "url"]

    mart <- useMart(biomart = "ensembl", dataset = "hsapiens_gene_ensembl", host = url)
    homolog <- listAttributes(mart)$name

    if (species_homolog %in% homolog) {
      cc_S_genes <- getBM(
        mart = mart,
        attributes = c(species_homolog),
        filters = c("external_gene_name"),
        values = list(Seurat::cc.genes.updated.2019$s.genes)
      )[[1]]
      cc_G2M_genes <- getBM(
        mart = mart,
        attributes = c(species_homolog),
        filters = c("external_gene_name"),
        values = list(Seurat::cc.genes.updated.2019$g2m.genes)
      )[[1]]

      if (length(cc_S_genes) < 3 | length(cc_G2M_genes) < 3) {
        warning(paste0("number of cell-cycle homolog genes is too small. CellCycleScoring will not performed."))
      }
    } else {
      warning(paste0("Can not find the homolog attributes for the species: ", species, " (", species_homolog, ")"))
      cc_S_genes <- cc_S_genes <- NA
    }
  }
  return(list(
    cc_S_genes = cc_S_genes,
    cc_G2M_genes = cc_G2M_genes
  ))
}

CC_module <- function(srt, cc_S_genes, cc_G2M_genes, ...) {
  if (length(cc_S_genes) >= 3 & length(cc_G2M_genes) >= 3) {
    srt <- CellCycleScoring(
      object = srt,
      s.features = cc_S_genes,
      g2m.features = cc_G2M_genes,
      set.ident = FALSE
    )
    srt[["CC.Difference"]] <- srt[["S.Score"]] - srt[["G2M.Score"]]
    srt[["Phase"]] <- factor(srt[["Phase", drop = TRUE]], levels = c("G1", "S", "G2M"))
  }
  return(srt)
}

SrtReorder <- function(srt, features = NULL, reorder_by = NULL, slot = "data", assay = NULL) {
  if (is.null(features)) {
    features <- VariableFeatures(srt)
  }
  features <- intersect(x = features, y = rownames(x = srt))
  if (is.null(reorder_by)) {
    srt$ident <- Idents(srt)
  } else {
    srt$ident <- srt[[reorder_by, drop = TRUE]]
  }
  if (is.null(assay)) {
    assay <- DefaultAssay(srt)
  }
  data.avg <- AverageExpression(object = srt, features = features, slot = slot, assays = assay, group.by = "ident")[[1]]
  data.dist <- dist(x = t(x = data.avg[features, ]))
  hc <- hclust(d = data.dist)
  ident_new <- plyr::mapvalues(x = srt$ident, from = hc$labels[hc$order], to = 1:length(hc$labels))
  ident_new <- factor(ident_new, levels = 1:length(hc$labels))
  Idents(srt) <- srt$ident <- ident_new
  return(srt)
}

Uncorrected_integrate <- function(srtList = NULL, srtMerge = NULL, append = FALSE,
                                  normalization_method = "logCPM", batch = "orig.ident",
                                  HVF_source = "separate", nHVF = 3000, hvf = NULL,
                                  maxPC = 100, resolution = 0.8, reorder = TRUE,
                                  reduction = "umap", reduction_prefix = "Uncorrected",
                                  exogenous_genes = NULL, ...) {
  if (is.null(srtList) & is.null(srtMerge)) {
    stop("srtList and srtMerge were all empty.")
  }
  if (!is.null(srtList) & !is.null(srtMerge)) {
    cell1 <- lapply(srtList, colnames) %>%
      unlist() %>%
      unique() %>%
      sort()
    cell2 <- colnames(srtMerge) %>%
      unique() %>%
      sort()
    if (!identical(cell1, cell2)) {
      stop("srtList and srtMerge have different cells.")
    }
  }
  if (isTRUE(append)) {
    if (is.null(srtMerge)) {
      stop("srtMerge must be provided when 'append = TRUE'.")
    } else {
      srtMerge_raw <- srtMerge
    }
  }
  if (!is.null(srtList)) {
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
    srtMerge <- Reduce(function(x, y) merge(x, y), srtList)
    VariableFeatures(srtMerge) <- hvf
  }
  if (is.null(srtList) & !is.null(srtMerge)) {
    checked <- Check_srtMerge(srtMerge,
      normalization_method = normalization_method, batch = batch,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = NULL
    )
    srtMerge <- checked[["srtMerge"]]
    hvf <- checked[["hvf"]]
  }

  srtIntegrated <- Standard_SCP(
    srt = srtMerge, normalization_method = normalization_method, nHVF = nHVF, hvf = hvf,
    maxPC = maxPC, resolution = resolution, reduction = reduction, reduction_prefix = reduction_prefix, reorder = reorder,
    exogenous_genes = exogenous_genes
  )
  srtIntegrated@project.name <- paste0(unique(srtIntegrated[[batch, drop = TRUE]]), collapse = ",")

  if (isTRUE(append)) {
    DefaultAssay(srtMerge_raw) <- "RNA"
    srtMerge_raw[[paste0(reduction_prefix, "pca")]] <- srtIntegrated[[paste0(reduction_prefix, "pca")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "Dims")]] <- srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "HVF")]] <- hvf
    srtMerge_raw[[paste0(reduction_prefix, "clusters")]] <- srtIntegrated[[paste0(reduction_prefix, "clusters")]]
    for (n in reduction_components) {
      for (i in reduction) {
        srtMerge_raw[[paste0(reduction_prefix, toupper(i), n, "d")]] <- srtIntegrated[[paste0(reduction_prefix, toupper(i), n, "d")]]
      }
    }
    return(srtMerge_raw)
  } else {
    return(srtIntegrated)
  }
}

Seurat_integrate <- function(srtList = NULL, srtMerge = NULL, append = FALSE,
                             normalization_method = "logCPM", batch = "orig.ident",
                             HVF_source = "separate", nHVF = 3000, hvf = NULL,
                             maxPC = 100, resolution = 0.8, reorder = TRUE,
                             reduction = "umap", reduction_prefix = "Seurat",
                             exogenous_genes = NULL, ...) {
  if (is.null(srtList) & is.null(srtMerge)) {
    stop("srtList and srtMerge were all empty.")
  }
  if (!is.null(srtList) & !is.null(srtMerge)) {
    cell1 <- lapply(srtList, colnames) %>%
      unlist() %>%
      unique() %>%
      sort()
    cell2 <- colnames(srtMerge) %>%
      unique() %>%
      sort()
    if (!identical(cell1, cell2)) {
      stop("srtList and srtMerge have different cells.")
    }
  }
  if (isTRUE(append)) {
    if (is.null(srtMerge)) {
      stop("srtMerge must be provided when 'append = TRUE'.")
    } else {
      srtMerge_raw <- srtMerge
    }
  }
  if (!is.null(srtList)) {
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
  }
  if (is.null(srtList) & !is.null(srtMerge)) {
    srtList <- SplitObject(object = srtMerge, split.by = batch)
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
  }

  srt_anchors <- FindIntegrationAnchors(
    object.list = srtList,
    normalization.method = switch(normalization_method,
      "logCPM" = "LogNormalize",
      "SCT" = "SCT"
    ),
    anchor.features = hvf,
    dims = 1:30
  )
  srtIntegrated <- IntegrateData(
    anchorset = srt_anchors,
    normalization.method = switch(normalization_method,
      "logCPM" = "LogNormalize",
      "SCT" = "SCT"
    ),
    dims = 1:30,
    features.to.integrate = c(
      hvf,
      Reduce(union, lapply(srtList, VariableFeatures)),
      Reduce(intersect, c(
        lapply(srtList, rownames),
        list(c(cc_S_genes, cc_G2M_genes))
      ))
    )
  )
  srtIntegrated <- RenameAssays(object = srtIntegrated, integrated = "Seurat")
  DefaultAssay(srtIntegrated) <- "Seurat"

  srtIntegrated <- Check_srtIntegrated(srtIntegrated, hvf = hvf, batch = batch)

  srtIntegrated <- ScaleData(srtIntegrated, features = hvf)
  srtIntegrated <- RunPCA(
    object = srtIntegrated, npcs = maxPC, features = hvf,
    reduction.name = paste0(reduction_prefix, "pca"),
    reduction.key = paste0(reduction_prefix, "pca_")
  )
  dims <- 1:ceiling(maxLikGlobalDimEst(data = Embeddings(srtIntegrated, reduction = paste0(reduction_prefix, "pca")), k = 20, iterations = 100)[["dim.est"]])
  srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]] <- dims

  srtIntegrated <- FindNeighbors(object = srtIntegrated, reduction = paste0(reduction_prefix, "pca"), dims = dims, force.recalc = T)
  srtIntegrated <- FindClusters(object = srtIntegrated, resolution = resolution, algorithm = 1, n.start = 100, n.iter = 10000)
  if (isTRUE(reorder)) {
    srtIntegrated <- SrtReorder(srtIntegrated, features = hvf, reorder_by = "seurat_clusters", slot = "data")
  }
  srtIntegrated[[paste0(reduction_prefix, "clusters")]] <- Idents(srtIntegrated)

  for (n in reduction_components) {
    if ("umap" %in% reduction) {
      srtIntegrated <- RunUMAP(
        object = srtIntegrated, reduction = paste0(reduction_prefix, "pca"),
        reduction.name = paste0(reduction_prefix, "UMAP", n, "d"),
        reduction.key = paste0(reduction_prefix, "UMAP", n, "d_"),
        dims = dims, n.components = n, umap.method = "uwot",
        return.model = TRUE, verbose = TRUE
      )
    }
    if ("tsne" %in% reduction) {
      srtIntegrated <- RunTSNE(
        object = srtIntegrated, reduction = paste0(reduction_prefix, "pca"),
        reduction.name = paste0(reduction_prefix, "TSNE", n, "d"),
        reduction.key = paste0(reduction_prefix, "TSNE", n, "d_"),
        dims = dims, dim.embed = n, tsne.method = "Rtsne",
        perplexity = max(ceiling(ncol(srtIntegrated) * 0.01), 30), max_iter = 2000,
        num_threads = 0, verbose = TRUE
      )
    }
  }

  DefaultAssay(srtIntegrated) <- "RNA"
  if (isTRUE(append)) {
    DefaultAssay(srtMerge_raw) <- "RNA"
    srtMerge_raw@assays$Seurat <- srtIntegrated@assays$Seurat
    srtMerge_raw[[paste0(reduction_prefix, "pca")]] <- srtIntegrated[[paste0(reduction_prefix, "pca")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "Dims")]] <- srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "HVF")]] <- hvf
    srtMerge_raw[[paste0(reduction_prefix, "clusters")]] <- srtIntegrated[[paste0(reduction_prefix, "clusters")]]
    for (n in reduction_components) {
      for (i in reduction) {
        srtMerge_raw[[paste0(reduction_prefix, toupper(i), n, "d")]] <- srtIntegrated[[paste0(reduction_prefix, toupper(i), n, "d")]]
      }
    }
    return(srtMerge_raw)
  } else {
    return(srtIntegrated)
  }
}

fastMNN_integrate <- function(srtList = NULL, srtMerge = NULL, append = FALSE,
                              normalization_method = "logCPM", batch = "orig.ident",
                              HVF_source = "separate", nHVF = 3000, hvf = NULL,
                              maxPC = 100, resolution = 0.8, reorder = TRUE,
                              reduction = "umap", reduction_prefix = "fastMNN",
                              exogenous_genes = NULL, ...) {
  require(SeuratWrappers)

  if (is.null(srtList) & is.null(srtMerge)) {
    stop("srtList and srtMerge were all empty.")
  }
  if (!is.null(srtList) & !is.null(srtMerge)) {
    cell1 <- lapply(srtList, colnames) %>%
      unlist() %>%
      unique() %>%
      sort()
    cell2 <- colnames(srtMerge) %>%
      unique() %>%
      sort()
    if (!identical(cell1, cell2)) {
      stop("srtList and srtMerge have different cells.")
    }
  }
  if (isTRUE(append)) {
    if (is.null(srtMerge)) {
      stop("srtMerge must be provided when 'append = TRUE'.")
    } else {
      srtMerge_raw <- srtMerge
    }
  }
  if (!is.null(srtList)) {
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
  }
  if (is.null(srtList) & !is.null(srtMerge)) {
    srtList <- SplitObject(object = srtMerge, split.by = batch)
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
  }

  srtIntegrated <- RunFastMNN(
    object.list = srtList,
    features = hvf,
    reduction.name = "fastMNN",
    reduction.key = "fastMNN_",
    assay = DefaultAssay(srtList[[1]]),
    BPPARAM = MulticoreParam()
  )

  srtIntegrated <- Check_srtIntegrated(srtIntegrated, hvf = hvf, batch = batch)

  dims <- 1:ceiling(maxLikGlobalDimEst(data = Embeddings(srtIntegrated, reduction = "fastMNN"), k = 20, iterations = 100)[["dim.est"]])
  srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]] <- dims

  srtIntegrated <- FindNeighbors(object = srtIntegrated, reduction = "fastMNN", dims = dims, force.recalc = T)
  srtIntegrated <- FindClusters(object = srtIntegrated, resolution = resolution, algorithm = 1, n.start = 100, n.iter = 10000)
  if (isTRUE(reorder)) {
    srtIntegrated <- SrtReorder(srtIntegrated, features = hvf, reorder_by = "seurat_clusters", slot = "data")
  }
  srtIntegrated[[paste0(reduction_prefix, "clusters")]] <- Idents(srtIntegrated)

  for (n in reduction_components) {
    if ("umap" %in% reduction) {
      srtIntegrated <- RunUMAP(
        object = srtIntegrated, reduction = "fastMNN",
        reduction.name = paste0(reduction_prefix, "UMAP", n, "d"),
        reduction.key = paste0(reduction_prefix, "UMAP", n, "d_"),
        dims = dims, n.components = n, umap.method = "uwot",
        return.model = TRUE, verbose = TRUE
      )
    }
    if ("tsne" %in% reduction) {
      srtIntegrated <- RunTSNE(
        object = srtIntegrated, reduction = "fastMNN",
        reduction.name = paste0(reduction_prefix, "TSNE", n, "d"),
        reduction.key = paste0(reduction_prefix, "TSNE", n, "d_"),
        dims = dims, dim.embed = n, tsne.method = "Rtsne",
        perplexity = max(ceiling(ncol(srtIntegrated) * 0.01), 30), max_iter = 2000,
        num_threads = 0, verbose = TRUE
      )
    }
  }

  DefaultAssay(srtIntegrated) <- "RNA"
  if (isTRUE(append)) {
    DefaultAssay(srtMerge_raw) <- "RNA"
    srtMerge_raw@reductions$fastMNN <- srtIntegrated@reductions$fastMNN
    srtMerge_raw@misc[[paste0(reduction_prefix, "Dims")]] <- srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "HVF")]] <- hvf
    srtMerge_raw[[paste0(reduction_prefix, "clusters")]] <- srtIntegrated[[paste0(reduction_prefix, "clusters")]]
    for (n in reduction_components) {
      for (i in reduction) {
        srtMerge_raw[[paste0(reduction_prefix, toupper(i), n, "d")]] <- srtIntegrated[[paste0(reduction_prefix, toupper(i), n, "d")]]
      }
    }
    return(srtMerge_raw)
  } else {
    return(srtIntegrated)
  }
}

Harmony_integrate <- function(srtList = NULL, srtMerge = NULL, append = FALSE,
                              normalization_method = "logCPM", batch = "orig.ident",
                              HVF_source = "separate", nHVF = 3000, hvf = NULL,
                              maxPC = 100, resolution = 0.8, reorder = TRUE,
                              reduction = "umap", reduction_prefix = "Harmony",
                              exogenous_genes = NULL, ...) {
  require(SeuratWrappers)

  if (is.null(srtList) & is.null(srtMerge)) {
    stop("srtList and srtMerge were all empty.")
  }
  if (!is.null(srtList) & !is.null(srtMerge)) {
    cell1 <- lapply(srtList, colnames) %>%
      unlist() %>%
      unique() %>%
      sort()
    cell2 <- colnames(srtMerge) %>%
      unique() %>%
      sort()
    if (!identical(cell1, cell2)) {
      stop("srtList and srtMerge have different cells.")
    }
  }
  if (isTRUE(append)) {
    if (is.null(srtMerge)) {
      stop("srtMerge must be provided when 'append = TRUE'.")
    } else {
      srtMerge_raw <- srtMerge
    }
  }
  if (!is.null(srtList)) {
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
    srtMerge <- Reduce(function(x, y) merge(x, y), srtList)
    VariableFeatures(srtMerge) <- hvf
  }
  if (is.null(srtList) & !is.null(srtMerge)) {
    checked <- Check_srtMerge(srtMerge,
      normalization_method = normalization_method, batch = batch,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = NULL
    )
    srtMerge <- checked[["srtMerge"]]
    hvf <- checked[["hvf"]]
  }

  srtMerge <- ScaleData(object = srtMerge, features = rownames(srtMerge))
  srtMerge <- RunPCA(
    object = srtMerge, npcs = maxPC, features = hvf,
    reduction.name = paste0(reduction_prefix, "pca"),
    reduction.key = paste0(reduction_prefix, "pca_")
  )
  dims <- 1:ceiling(maxLikGlobalDimEst(data = Embeddings(srtMerge, reduction = paste0(reduction_prefix, "pca")), k = 20, iterations = 100)[["dim.est"]])

  srtIntegrated <- RunHarmony(
    object = srtMerge,
    group.by.vars = batch,
    reduction = paste0(reduction_prefix, "pca"),
    dims.use = dims,
    reduction.save = "Harmony",
    assay.use = DefaultAssay(srtMerge)
  )
  srtMerge <- NULL

  srtIntegrated <- Check_srtIntegrated(srtIntegrated, hvf = hvf, batch = batch)

  dims <- 1:ceiling(maxLikGlobalDimEst(data = Embeddings(srtIntegrated, reduction = "Harmony"), k = 20, iterations = 100)[["dim.est"]])
  srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]] <- dims

  srtIntegrated <- FindNeighbors(object = srtIntegrated, reduction = "Harmony", dims = dims, force.recalc = T)
  srtIntegrated <- FindClusters(object = srtIntegrated, resolution = resolution, algorithm = 1, n.start = 100, n.iter = 10000)
  if (isTRUE(reorder)) {
    srtIntegrated <- SrtReorder(srtIntegrated, features = hvf, reorder_by = "seurat_clusters", slot = "data")
  }
  srtIntegrated[[paste0(reduction_prefix, "clusters")]] <- Idents(srtIntegrated)

  for (n in reduction_components) {
    if ("umap" %in% reduction) {
      srtIntegrated <- RunUMAP(
        object = srtIntegrated, reduction = "Harmony",
        reduction.name = paste0(reduction_prefix, "UMAP", n, "d"),
        reduction.key = paste0(reduction_prefix, "UMAP", n, "d_"),
        dims = dims, n.components = n, umap.method = "uwot",
        return.model = TRUE, verbose = TRUE
      )
    }
    if ("tsne" %in% reduction) {
      srtIntegrated <- RunTSNE(
        object = srtIntegrated, reduction = "Harmony",
        reduction.name = paste0(reduction_prefix, "TSNE", n, "d"),
        reduction.key = paste0(reduction_prefix, "TSNE", n, "d_"),
        dims = dims, dim.embed = n, tsne.method = "Rtsne",
        perplexity = max(ceiling(ncol(srtIntegrated) * 0.01), 30), max_iter = 2000,
        num_threads = 0, verbose = TRUE
      )
    }
  }

  DefaultAssay(srtIntegrated) <- "RNA"
  if (isTRUE(append)) {
    DefaultAssay(srtMerge_raw) <- "RNA"
    srtMerge_raw@reductions$Harmony <- srtIntegrated@reductions$Harmony
    srtMerge_raw@misc[[paste0(reduction_prefix, "Dims")]] <- srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "HVF")]] <- hvf
    srtMerge_raw[[paste0(reduction_prefix, "clusters")]] <- srtIntegrated[[paste0(reduction_prefix, "clusters")]]
    for (n in reduction_components) {
      for (i in reduction) {
        srtMerge_raw[[paste0(reduction_prefix, toupper(i), n, "d")]] <- srtIntegrated[[paste0(reduction_prefix, toupper(i), n, "d")]]
      }
    }
    return(srtMerge_raw)
  } else {
    return(srtIntegrated)
  }
}

Concos_integrate <- function(srtList = NULL, srtMerge = NULL, append = FALSE,
                             normalization_method = "logCPM", batch = "orig.ident",
                             HVF_source = "separate", nHVF = 3000, hvf = NULL,
                             maxPC = 100, resolution = 0.8, reorder = TRUE,
                             reduction = "umap", reduction_prefix = "Harmony",
                             exogenous_genes = NULL, ...) {
  require(SeuratWrappers)
  require(conos)

  if (is.null(srtList) & is.null(srtMerge)) {
    stop("srtList and srtMerge were all empty.")
  }
  if (!is.null(srtList) & !is.null(srtMerge)) {
    cell1 <- lapply(srtList, colnames) %>%
      unlist() %>%
      unique() %>%
      sort()
    cell2 <- colnames(srtMerge) %>%
      unique() %>%
      sort()
    if (!identical(cell1, cell2)) {
      stop("srtList and srtMerge have different cells.")
    }
  }
  if (isTRUE(append)) {
    if (is.null(srtMerge)) {
      stop("srtMerge must be provided when 'append = TRUE'.")
    } else {
      srtMerge_raw <- srtMerge
    }
  }
  if (!is.null(srtList)) {
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
  }
  if (is.null(srtList) & !is.null(srtMerge)) {
    srtList <- SplitObject(object = srtMerge, split.by = batch)
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
  }

  srtIntegrated <- Conos$new(srtList)
  srtIntegrated$buildGraph(
    k = 15, k.self = 10, space = "PCA", ncomps = 40, n.odgenes = nHVF, matching.method = "mNN",
    metric = "angular", score.component.variance = TRUE, verbose = TRUE
  )
  srtIntegrated$findCommunities()
  srtIntegrated$embedGraph()
  srtIntegrated <- as.Seurat(srtIntegrated)

  srtIntegrated <- Check_srtIntegrated(srtIntegrated, hvf = hvf, batch = batch)

  dims <- 1:ceiling(maxLikGlobalDimEst(data = Embeddings(srtIntegrated, reduction = "fastMNN"), k = 20, iterations = 100)[["dim.est"]])
  srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]] <- dims

  srtIntegrated <- FindNeighbors(object = srtIntegrated, reduction = "fastMNN", dims = dims, force.recalc = T)
  srtIntegrated <- FindClusters(object = srtIntegrated, resolution = resolution, algorithm = 1, n.start = 100, n.iter = 10000)
  if (isTRUE(reorder)) {
    srtIntegrated <- SrtReorder(srtIntegrated, features = hvf, reorder_by = "seurat_clusters", slot = "data")
  }
  srtIntegrated[[paste0(reduction_prefix, "clusters")]] <- Idents(srtIntegrated)

  for (n in reduction_components) {
    if ("umap" %in% reduction) {
      srtIntegrated <- RunUMAP(
        object = srtIntegrated, reduction = "fastMNN",
        reduction.name = paste0(reduction_prefix, "UMAP", n, "d"),
        reduction.key = paste0(reduction_prefix, "UMAP", n, "d_"),
        dims = dims, n.components = n, umap.method = "uwot",
        return.model = TRUE, verbose = TRUE
      )
    }
    if ("tsne" %in% reduction) {
      srtIntegrated <- RunTSNE(
        object = srtIntegrated, reduction = "fastMNN",
        reduction.name = paste0(reduction_prefix, "TSNE", n, "d"),
        reduction.key = paste0(reduction_prefix, "TSNE", n, "d_"),
        dims = dims, dim.embed = n, tsne.method = "Rtsne",
        perplexity = max(ceiling(ncol(srtIntegrated) * 0.01), 30), max_iter = 2000,
        num_threads = 0, verbose = TRUE
      )
    }
  }

  DefaultAssay(srtIntegrated) <- "RNA"
  if (isTRUE(append)) {
    DefaultAssay(srtMerge_raw) <- "RNA"
    srtMerge_raw@reductions$fastMNN <- srtIntegrated@reductions$fastMNN
    srtMerge_raw@misc[[paste0(reduction_prefix, "Dims")]] <- srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "HVF")]] <- hvf
    srtMerge_raw[[paste0(reduction_prefix, "clusters")]] <- srtIntegrated[[paste0(reduction_prefix, "clusters")]]
    for (n in reduction_components) {
      for (i in reduction) {
        srtMerge_raw[[paste0(reduction_prefix, toupper(i), n, "d")]] <- srtIntegrated[[paste0(reduction_prefix, toupper(i), n, "d")]]
      }
    }
    return(srtMerge_raw)
  } else {
    return(srtIntegrated)
  }
}

Scanorama_integrate <- function(srtList = NULL, srtMerge = NULL, append = FALSE,
                                normalization_method = "logCPM", batch = "orig.ident",
                                HVF_source = "separate", nHVF = 3000, hvf = NULL,
                                maxPC = 100, resolution = 0.8, reorder = TRUE,
                                reduction = "umap", reduction_prefix = "Scanorama",
                                exogenous_genes = NULL, ...) {
  require(reticulate)
  require(plyr)
  scanorama <- reticulate::import("scanorama")

  if (is.null(srtList) & is.null(srtMerge)) {
    stop("srtList and srtMerge were all empty.")
  }
  if (!is.null(srtList) & !is.null(srtMerge)) {
    cell1 <- lapply(srtList, colnames) %>%
      unlist() %>%
      unique() %>%
      sort()
    cell2 <- colnames(srtMerge) %>%
      unique() %>%
      sort()
    if (!identical(cell1, cell2)) {
      stop("srtList and srtMerge have different cells.")
    }
  }
  if (isTRUE(append)) {
    if (is.null(srtMerge)) {
      stop("srtMerge must be provided when 'append = TRUE'.")
    } else {
      srtMerge_raw <- srtMerge
    }
  }
  if (!is.null(srtList)) {
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
  }
  if (is.null(srtList) & !is.null(srtMerge)) {
    srtList <- SplitObject(object = srtMerge, split.by = batch)
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
  }

  assaylist <- list()
  genelist <- list()
  for (i in 1:length(srtList)) {
    assaylist[[i]] <- t(as.matrix(GetAssayData(object = srtList[[i]], slot = "data")))
    genelist[[i]] <- rownames(srtList[[i]])
  }

  integrated.corrected.data <- scanorama$correct(
    datasets_full = assaylist,
    genes_list = genelist,
    return_dimred = TRUE,
    return_dense = TRUE,
    union = FALSE
  )

  cor_value <- integrated.corrected.data[[2]] %>%
    rbind.fill.matrix() %>%
    t()
  rownames(cor_value) <- integrated.corrected.data[[3]]
  colnames(cor_value) <- unlist(sapply(assaylist, rownames))

  dim_reduction <- integrated.corrected.data[[1]] %>% rbind.fill.matrix()
  rownames(dim_reduction) <- unlist(sapply(assaylist, rownames))
  colnames(dim_reduction) <- paste0("Scanorama_", 1:100)
  stdevs <- apply(dim_reduction, MARGIN = 2, FUN = sd)

  srtIntegrated <- Reduce(function(x, y) merge(x, y), srtList)
  srtIntegrated[["Scanorama"]] <- CreateAssayObject(data = cor_value)
  srtIntegrated[["Scanorama_reduction"]] <- CreateDimReducObject(embeddings = dim_reduction, assay = "Scanorama", stdev = stdevs, key = "Scanorama_")
  DefaultAssay(srtIntegrated) <- "Scanorama"

  srtIntegrated <- Check_srtIntegrated(srtIntegrated, hvf = hvf, batch = batch)

  srtIntegrated <- ScaleData(srtIntegrated, features = hvf)
  srtIntegrated <- RunPCA(
    object = srtIntegrated, npcs = maxPC, features = hvf,
    reduction.name = paste0(reduction_prefix, "pca"),
    reduction.key = paste0(reduction_prefix, "pca_")
  )
  dims <- 1:ceiling(maxLikGlobalDimEst(data = Embeddings(srtIntegrated, reduction = paste0(reduction_prefix, "pca")), k = 20, iterations = 100)[["dim.est"]])
  srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]] <- dims

  srtIntegrated <- FindNeighbors(object = srtIntegrated, reduction = paste0(reduction_prefix, "pca"), dims = dims, force.recalc = T)
  srtIntegrated <- FindClusters(object = srtIntegrated, resolution = resolution, algorithm = 1, n.start = 100, n.iter = 10000)
  if (isTRUE(reorder)) {
    srtIntegrated <- SrtReorder(srtIntegrated, features = hvf, reorder_by = "seurat_clusters", slot = "data")
  }
  srtIntegrated[[paste0(reduction_prefix, "clusters")]] <- Idents(srtIntegrated)

  for (n in reduction_components) {
    if ("umap" %in% reduction) {
      srtIntegrated <- RunUMAP(
        object = srtIntegrated, reduction = paste0(reduction_prefix, "pca"),
        reduction.name = paste0(reduction_prefix, "UMAP", n, "d"),
        reduction.key = paste0(reduction_prefix, "UMAP", n, "d_"),
        dims = dims, n.components = n, umap.method = "uwot",
        return.model = TRUE, verbose = TRUE
      )
    }
    if ("tsne" %in% reduction) {
      srtIntegrated <- RunTSNE(
        object = srtIntegrated, reduction = paste0(reduction_prefix, "pca"),
        reduction.name = paste0(reduction_prefix, "TSNE", n, "d"),
        reduction.key = paste0(reduction_prefix, "TSNE", n, "d_"),
        dims = dims, dim.embed = n, tsne.method = "Rtsne",
        perplexity = max(ceiling(ncol(srtIntegrated) * 0.01), 30), max_iter = 2000,
        num_threads = 0, verbose = TRUE
      )
    }
  }

  DefaultAssay(srtIntegrated) <- "RNA"
  if (isTRUE(append)) {
    DefaultAssay(srtMerge_raw) <- "RNA"
    srtMerge_raw@assays$Scanorama <- srtIntegrated@assays$Scanorama
    srtMerge_raw@reductions$Scanorama_reduction <- srtIntegrated@reductions$Scanorama_reduction
    srtMerge_raw[[paste0(reduction_prefix, "pca")]] <- srtIntegrated[[paste0(reduction_prefix, "pca")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "Dims")]] <- srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "HVF")]] <- hvf
    srtMerge_raw[[paste0(reduction_prefix, "clusters")]] <- srtIntegrated[[paste0(reduction_prefix, "clusters")]]
    for (n in reduction_components) {
      for (i in reduction) {
        srtMerge_raw[[paste0(reduction_prefix, toupper(i), n, "d")]] <- srtIntegrated[[paste0(reduction_prefix, toupper(i), n, "d")]]
      }
    }
    return(srtMerge_raw)
  } else {
    return(srtIntegrated)
  }
}

BBKNN_integrate <- function(srtList = NULL, srtMerge = NULL, append = FALSE,
                            normalization_method = "logCPM", batch = "orig.ident",
                            HVF_source = "separate", nHVF = 3000, hvf = NULL,
                            maxPC = 100, resolution = 0.8, reorder = TRUE,
                            reduction_prefix = "BBKNN",
                            exogenous_genes = NULL, ...) {
  require(reticulate)
  bbknn <- reticulate::import("bbknn", convert = FALSE)

  if (is.null(srtList) & is.null(srtMerge)) {
    stop("srtList and srtMerge were all empty.")
  }
  if (!is.null(srtList) & !is.null(srtMerge)) {
    cell1 <- lapply(srtList, colnames) %>%
      unlist() %>%
      unique() %>%
      sort()
    cell2 <- colnames(srtMerge) %>%
      unique() %>%
      sort()
    if (!identical(cell1, cell2)) {
      stop("srtList and srtMerge have different cells.")
    }
  }
  if (isTRUE(append)) {
    if (is.null(srtMerge)) {
      stop("srtMerge must be provided when 'append = TRUE'.")
    } else {
      srtMerge_raw <- srtMerge
    }
  }
  if (!is.null(srtList)) {
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
    srtMerge <- Reduce(function(x, y) merge(x, y), srtList)
    VariableFeatures(srtMerge) <- hvf
  }
  if (is.null(srtList) & !is.null(srtMerge)) {
    checked <- Check_srtMerge(srtMerge,
      normalization_method = normalization_method, batch = batch,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = NULL
    )
    srtMerge <- checked[["srtMerge"]]
    hvf <- checked[["hvf"]]
  }

  srtMerge <- ScaleData(object = srtMerge, features = rownames(srtMerge))
  srtMerge <- RunPCA(
    object = srtMerge, npcs = maxPC, features = hvf,
    reduction.name = paste0(reduction_prefix, "pca"),
    reduction.key = paste0(reduction_prefix, "pca_")
  )
  dims <- 1:ceiling(maxLikGlobalDimEst(data = Embeddings(srtMerge, reduction = paste0(reduction_prefix, "pca")), k = 20, iterations = 100)[["dim.est"]])
  srtMerge@misc[[paste0(reduction_prefix, "Dims")]] <- dims

  pca <- reticulate::r_to_py(Embeddings(srtMerge, reduction = paste0(reduction_prefix, "pca"))[, dims])
  bem <- bbknn$bbknn_pca_matrix(pca, batch_list = srtMerge[[batch, drop = TRUE]])
  bem <- reticulate::py_to_r(bem)
  bbknn_graph <- as(as(bem[[2]], "CsparseMatrix"), "dgCMatrix")
  rownames(bbknn_graph) <- colnames(bbknn_graph) <- colnames(srtMerge)
  srtMerge@graphs$BBKNN <- as.Graph(bbknn_graph)
  srtIntegrated <- srtMerge
  srtMerge <- NULL

  srtIntegrated <- Check_srtIntegrated(srtIntegrated, hvf = hvf, batch = batch)

  srtIntegrated <- FindClusters(object = srtIntegrated, graph.name = "BBKNN", resolution = resolution, algorithm = 1, n.start = 100, n.iter = 10000)
  if (isTRUE(reorder)) {
    srtIntegrated <- SrtReorder(srtIntegrated, features = hvf, reorder_by = "seurat_clusters", slot = "data")
  }
  srtIntegrated[[paste0(reduction_prefix, "clusters")]] <- Idents(srtIntegrated)

  reduction <- "umap"
  for (n in reduction_components) {
    srtIntegrated <- RunUMAP(
      object = srtIntegrated, graph = "BBKNN",
      umap.method = "umap-learn", metric = "correlation",
      reduction.name = paste0(reduction_prefix, "UMAP", n, "d"),
      reduction.key = paste0(reduction_prefix, "UMAP", n, "d_"),
      n.components = as.integer(n),
      return.model = TRUE, verbose = TRUE
    )
  }

  DefaultAssay(srtIntegrated) <- "RNA"
  if (isTRUE(append)) {
    DefaultAssay(srtMerge_raw) <- "RNA"
    srtMerge_raw@graphs$BBKNN <- srtIntegrated@graphs$BBKNN
    srtMerge_raw@misc[[paste0(reduction_prefix, "Dims")]] <- srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "HVF")]] <- hvf
    srtMerge_raw[[paste0(reduction_prefix, "clusters")]] <- srtIntegrated[[paste0(reduction_prefix, "clusters")]]
    for (n in reduction_components) {
      for (i in reduction) {
        srtMerge_raw[[paste0(reduction_prefix, toupper(i), n, "d")]] <- srtIntegrated[[paste0(reduction_prefix, toupper(i), n, "d")]]
      }
    }
    return(srtMerge_raw)
  } else {
    return(srtIntegrated)
  }
}

CSS_integrate <- function(srtList = NULL, srtMerge = NULL, append = FALSE,
                          normalization_method = "logCPM", batch = "orig.ident",
                          HVF_source = "separate", nHVF = 3000, hvf = NULL,
                          maxPC = 100, resolution = 0.8, reorder = TRUE,
                          reduction = "umap", reduction_prefix = "CSS",
                          exogenous_genes = NULL, ...) {
  require(simspec)

  if (is.null(srtList) & is.null(srtMerge)) {
    stop("srtList and srtMerge were all empty.")
  }
  if (!is.null(srtList) & !is.null(srtMerge)) {
    cell1 <- lapply(srtList, colnames) %>%
      unlist() %>%
      unique() %>%
      sort()
    cell2 <- colnames(srtMerge) %>%
      unique() %>%
      sort()
    if (!identical(cell1, cell2)) {
      stop("srtList and srtMerge have different cells.")
    }
  }
  if (isTRUE(append)) {
    if (is.null(srtMerge)) {
      stop("srtMerge must be provided when 'append = TRUE'.")
    } else {
      srtMerge_raw <- srtMerge
    }
  }
  if (!is.null(srtList)) {
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
    srtMerge <- Reduce(function(x, y) merge(x, y), srtList)
    VariableFeatures(srtMerge) <- hvf
  }
  if (is.null(srtList) & !is.null(srtMerge)) {
    checked <- Check_srtMerge(srtMerge,
      normalization_method = normalization_method, batch = batch,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = NULL
    )
    srtMerge <- checked[["srtMerge"]]
    hvf <- checked[["hvf"]]
  }

  srtMerge <- ScaleData(object = srtMerge, features = rownames(srtMerge))
  srtMerge <- RunPCA(
    object = srtMerge, npcs = maxPC, features = hvf,
    reduction.name = paste0(reduction_prefix, "pca"),
    reduction.key = paste0(reduction_prefix, "pca_")
  )
  dims <- 1:ceiling(maxLikGlobalDimEst(data = Embeddings(srtMerge, reduction = paste0(reduction_prefix, "pca")), k = 20, iterations = 100)[["dim.est"]])

  srtIntegrated <- cluster_sim_spectrum(
    object = srtMerge,
    use_dr = paste0(reduction_prefix, "pca"),
    dims_use = dims,
    var_genes = hvf,
    label_tag = batch,
    cluster_resolution = 0.4,
    # corr_method = "pearson",
    # spectrum_type = "corr_kernel"
    reduction.name = "CSS",
    reduction.key = "CSS_"
  )
  srtMerge <- NULL

  srtIntegrated <- Check_srtIntegrated(srtIntegrated, hvf = hvf, batch = batch)

  dims <- 1:ncol(Embeddings(srtIntegrated, reduction = "CSS"))
  srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]] <- dims

  srtIntegrated <- FindNeighbors(object = srtIntegrated, reduction = "CSS", dims = dims, force.recalc = T)
  srtIntegrated <- FindClusters(object = srtIntegrated, resolution = resolution, algorithm = 1, n.start = 100, n.iter = 10000)
  if (isTRUE(reorder)) {
    srtIntegrated <- SrtReorder(srtIntegrated, features = hvf, reorder_by = "seurat_clusters", slot = "data")
  }
  srtIntegrated[[paste0(reduction_prefix, "clusters")]] <- Idents(srtIntegrated)

  for (n in reduction_components) {
    if ("umap" %in% reduction) {
      srtIntegrated <- RunUMAP(
        object = srtIntegrated, reduction = "CSS",
        reduction.name = paste0(reduction_prefix, "UMAP", n, "d"),
        reduction.key = paste0(reduction_prefix, "UMAP", n, "d_"),
        dims = dims, n.components = n, umap.method = "uwot",
        return.model = TRUE, verbose = TRUE
      )
    }
    if ("tsne" %in% reduction) {
      srtIntegrated <- RunTSNE(
        object = srtIntegrated, reduction = "CSS",
        reduction.name = paste0(reduction_prefix, "TSNE", n, "d"),
        reduction.key = paste0(reduction_prefix, "TSNE", n, "d_"),
        dims = dims, dim.embed = n, tsne.method = "Rtsne",
        perplexity = max(ceiling(ncol(srtIntegrated) * 0.01), 30), max_iter = 2000,
        num_threads = 0, verbose = TRUE
      )
    }
  }

  DefaultAssay(srtIntegrated) <- "RNA"
  if (isTRUE(append)) {
    DefaultAssay(srtMerge_raw) <- "RNA"
    srtMerge_raw@reductions$CSS <- srtIntegrated@reductions$CSS
    srtMerge_raw@misc[[paste0(reduction_prefix, "Dims")]] <- srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "HVF")]] <- hvf
    srtMerge_raw[[paste0(reduction_prefix, "clusters")]] <- srtIntegrated[[paste0(reduction_prefix, "clusters")]]
    for (n in reduction_components) {
      for (i in reduction) {
        srtMerge_raw[[paste0(reduction_prefix, toupper(i), n, "d")]] <- srtIntegrated[[paste0(reduction_prefix, toupper(i), n, "d")]]
      }
    }
    return(srtMerge_raw)
  } else {
    return(srtIntegrated)
  }
}

LIGER_integrate <- function(srtList = NULL, srtMerge = NULL, append = FALSE,
                            normalization_method = "logCPM", batch = "orig.ident",
                            HVF_source = "separate", nHVF = 3000, hvf = NULL,
                            maxPC = 100, resolution = 0.8, reorder = TRUE,
                            reduction = "umap", reduction_prefix = "LIGER",
                            exogenous_genes = NULL, ...) {
  require(SeuratWrappers)
  require(rliger)

  if (is.null(srtList) & is.null(srtMerge)) {
    stop("srtList and srtMerge were all empty.")
  }
  if (!is.null(srtList) & !is.null(srtMerge)) {
    cell1 <- lapply(srtList, colnames) %>%
      unlist() %>%
      unique() %>%
      sort()
    cell2 <- colnames(srtMerge) %>%
      unique() %>%
      sort()
    if (!identical(cell1, cell2)) {
      stop("srtList and srtMerge have different cells.")
    }
  }
  if (isTRUE(append)) {
    if (is.null(srtMerge)) {
      stop("srtMerge must be provided when 'append = TRUE'.")
    } else {
      srtMerge_raw <- srtMerge
    }
  }
  if (!is.null(srtList)) {
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
    srtMerge <- Reduce(function(x, y) merge(x, y), srtList)
    VariableFeatures(srtMerge) <- hvf
  }
  if (is.null(srtList) & !is.null(srtMerge)) {
    checked <- Check_srtMerge(srtMerge,
      normalization_method = normalization_method, batch = batch,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = NULL
    )
    srtMerge <- checked[["srtMerge"]]
    hvf <- checked[["hvf"]]
  }

  srtMerge <- ScaleData(object = srtMerge, features = hvf, split.by = batch, do.center = FALSE)

  srtMerge <- RunOptimizeALS(srtMerge,
    k = 20,
    lambda = 5,
    split.by = batch
  )
  srtIntegrated <- RunQuantileNorm(srtMerge,
    reduction.name = "LIGER",
    reduction.key = "LIGER_",
    split.by = batch
  )
  srtMerge <- NULL

  srtIntegrated <- Check_srtIntegrated(srtIntegrated, hvf = hvf, batch = batch)

  dims <- 1:ncol(Embeddings(srtIntegrated, reduction = "LIGER"))
  srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]] <- dims

  srtIntegrated <- FindNeighbors(object = srtIntegrated, reduction = "LIGER", dims = dims, force.recalc = T)
  srtIntegrated <- FindClusters(object = srtIntegrated, resolution = resolution, algorithm = 1, n.start = 100, n.iter = 10000)
  if (isTRUE(reorder)) {
    srtIntegrated <- SrtReorder(srtIntegrated, features = hvf, reorder_by = "seurat_clusters", slot = "data")
  }
  srtIntegrated[[paste0(reduction_prefix, "clusters")]] <- Idents(srtIntegrated)

  for (n in reduction_components) {
    if ("umap" %in% reduction) {
      srtIntegrated <- RunUMAP(
        object = srtIntegrated, reduction = "LIGER",
        reduction.name = paste0(reduction_prefix, "UMAP", n, "d"),
        reduction.key = paste0(reduction_prefix, "UMAP", n, "d_"),
        dims = dims, n.components = n, umap.method = "uwot",
        return.model = TRUE, verbose = TRUE
      )
    }
    if ("tsne" %in% reduction) {
      srtIntegrated <- RunTSNE(
        object = srtIntegrated, reduction = "LIGER",
        reduction.name = paste0(reduction_prefix, "TSNE", n, "d"),
        reduction.key = paste0(reduction_prefix, "TSNE", n, "d_"),
        dims = dims, dim.embed = n, tsne.method = "Rtsne",
        perplexity = max(ceiling(ncol(srtIntegrated) * 0.01), 30), max_iter = 2000,
        num_threads = 0, verbose = TRUE
      )
    }
  }

  DefaultAssay(srtIntegrated) <- "RNA"
  if (isTRUE(append)) {
    DefaultAssay(srtMerge_raw) <- "RNA"
    srtMerge_raw@reductions$LIGER <- srtIntegrated@reductions$LIGER
    srtMerge_raw@misc[[paste0(reduction_prefix, "Dims")]] <- srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "HVF")]] <- hvf
    srtMerge_raw[[paste0(reduction_prefix, "clusters")]] <- srtIntegrated[[paste0(reduction_prefix, "clusters")]]
    for (n in reduction_components) {
      for (i in reduction) {
        srtMerge_raw[[paste0(reduction_prefix, toupper(i), n, "d")]] <- srtIntegrated[[paste0(reduction_prefix, toupper(i), n, "d")]]
      }
    }
    return(srtMerge_raw)
  } else {
    return(srtIntegrated)
  }
}

## slow
scMerge_integrate <- function(srtList = NULL, srtMerge = NULL, append = FALSE,
                              normalization_method = "logCPM", batch = "orig.ident",
                              HVF_source = "separate", nHVF = 3000, hvf = NULL,
                              maxPC = 100, resolution = 0.8, reorder = TRUE,
                              reduction = "umap", reduction_prefix = "scMerge",
                              exogenous_genes = NULL, ...) {
  require(scMerge)
  if (is.null(srtList) & is.null(srtMerge)) {
    stop("srtList and srtMerge were all empty.")
  }
  if (!is.null(srtList) & !is.null(srtMerge)) {
    cell1 <- lapply(srtList, colnames) %>%
      unlist() %>%
      unique() %>%
      sort()
    cell2 <- colnames(srtMerge) %>%
      unique() %>%
      sort()
    if (!identical(cell1, cell2)) {
      stop("srtList and srtMerge have different cells.")
    }
  }
  if (isTRUE(append)) {
    if (is.null(srtMerge)) {
      stop("srtMerge must be provided when 'append = TRUE'.")
    } else {
      srtMerge_raw <- srtMerge
    }
  }
  if (!is.null(srtList)) {
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
    srtMerge <- Reduce(function(x, y) merge(x, y), srtList)
    VariableFeatures(srtMerge) <- hvf
  }
  if (is.null(srtList) & !is.null(srtMerge)) {
    checked <- Check_srtMerge(srtMerge,
      normalization_method = normalization_method, batch = batch,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = NULL
    )
    srtMerge <- checked[["srtMerge"]]
    hvf <- checked[["hvf"]]
  }

  assay_use <- GetAssay(
    object = srtMerge,
    assay = switch(normalization_method,
      "logCPM" = "RNA",
      "SCT" = "SCT"
    )
  )
  sce <- SingleCellExperiment(
    assays = list(counts = assay_use@counts, logcounts = assay_use@data),
    colData = DataFrame(srtMerge@meta.data)
  )
  assay(sce, "counts") <- as(counts(sce), "dgeMatrix")
  assay(sce, "logcounts") <- as(logcounts(sce), "dgeMatrix")

  data("segList", package = "scMerge")
  scSEG <- segList$human$human_scSEG
  scSEG <- scSEG[scSEG %in% rownames(sce)]

  kmeansK <- sapply(srtList, function(x) {
    if (!"seurat_clusters" %in% colnames(x@meta.data)) {
      x <- x %>%
        RunPCA(npcs = maxPC, verbose = FALSE) %>%
        FindNeighbors() %>%
        FindClusters(resolution = resolution, algorithm = 1, n.start = 100, n.iter = 10000)
    }
    i <- nlevels(x[["seurat_clusters", drop = TRUE]])
  })

  sce_scMerge <- scMerge(
    sce_combine = sce,
    ctl = scSEG,
    kmeansK = kmeansK,
    batch_name = batch,
    assay_name = "scMerge",
    BSPARAM = IrlbaParam(),
    # BPPARAM = MulticoreParam(),
    plot_igraph = FALSE
  )
  assay(sce_scMerge, "counts") <- as(assay(sce_scMerge, "counts"), "dgCMatrix")
  assay(sce_scMerge, "scMerge") <- as(assay(sce_scMerge, "scMerge"), "dgCMatrix")
  srtIntegrated <- as.Seurat(
    x = sce_scMerge,
    counts = "counts",
    data = "scMerge"
  )
  srtIntegrated <- RenameAssays(srtIntegrated, originalexp = "scMerge")
  srtIntegrated@assays$RNA <- srtMerge@assays$RNA
  DefaultAssay(srtIntegrated) <- "scMerge"
  sce_scMerge <- sce <- NULL

  srtIntegrated <- Check_srtIntegrated(srtIntegrated, hvf = hvf, batch = batch)

  srtIntegrated <- ScaleData(srtIntegrated, features = hvf)
  srtIntegrated <- RunPCA(
    object = srtIntegrated, npcs = maxPC, features = hvf,
    reduction.name = paste0(reduction_prefix, "pca"),
    reduction.key = paste0(reduction_prefix, "pca_")
  )
  dims <- 1:ceiling(maxLikGlobalDimEst(data = Embeddings(srtIntegrated, reduction = paste0(reduction_prefix, "pca")), k = 20, iterations = 100)[["dim.est"]])
  srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]] <- dims

  srtIntegrated <- FindNeighbors(object = srtIntegrated, reduction = paste0(reduction_prefix, "pca"), dims = dims, force.recalc = T)
  srtIntegrated <- FindClusters(object = srtIntegrated, resolution = resolution, algorithm = 1, n.start = 100, n.iter = 10000)
  if (isTRUE(reorder)) {
    srtIntegrated <- SrtReorder(srtIntegrated, features = hvf, reorder_by = "seurat_clusters", slot = "data")
  }
  srtIntegrated[[paste0(reduction_prefix, "clusters")]] <- Idents(srtIntegrated)

  for (n in reduction_components) {
    if ("umap" %in% reduction) {
      srtIntegrated <- RunUMAP(
        object = srtIntegrated, reduction = paste0(reduction_prefix, "pca"),
        reduction.name = paste0(reduction_prefix, "UMAP", n, "d"),
        reduction.key = paste0(reduction_prefix, "UMAP", n, "d_"),
        dims = dims, n.components = n, umap.method = "uwot",
        return.model = TRUE, verbose = TRUE
      )
    }
    if ("tsne" %in% reduction) {
      srtIntegrated <- RunTSNE(
        object = srtIntegrated, reduction = paste0(reduction_prefix, "pca"),
        reduction.name = paste0(reduction_prefix, "TSNE", n, "d"),
        reduction.key = paste0(reduction_prefix, "TSNE", n, "d_"),
        dims = dims, dim.embed = n, tsne.method = "Rtsne",
        perplexity = max(ceiling(ncol(srtIntegrated) * 0.01), 30), max_iter = 2000,
        num_threads = 0, verbose = TRUE
      )
    }
  }

  DefaultAssay(srtIntegrated) <- "RNA"
  if (isTRUE(append)) {
    DefaultAssay(srtMerge_raw) <- "RNA"
    srtMerge_raw@assays$scMerge <- srtIntegrated@assays$scMerge
    srtMerge_raw[[paste0(reduction_prefix, "pca")]] <- srtIntegrated[[paste0(reduction_prefix, "pca")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "Dims")]] <- srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "HVF")]] <- hvf
    srtMerge_raw[[paste0(reduction_prefix, "clusters")]] <- srtIntegrated[[paste0(reduction_prefix, "clusters")]]
    for (n in reduction_components) {
      for (i in reduction) {
        srtMerge_raw[[paste0(reduction_prefix, toupper(i), n, "d")]] <- srtIntegrated[[paste0(reduction_prefix, toupper(i), n, "d")]]
      }
    }
    return(srtMerge_raw)
  } else {
    return(srtIntegrated)
  }
}

ZINBWaVE_integrate <- function(srtList = NULL, srtMerge = NULL, append = FALSE,
                               normalization_method = "logCPM", batch = "orig.ident",
                               HVF_source = "separate", nHVF = 3000, hvf = NULL,
                               maxPC = 100, resolution = 0.8, reorder = TRUE,
                               reduction = "umap", reduction_prefix = "ZINBWaVE",
                               exogenous_genes = NULL, ...) {
  require(zinbwave)
  if (is.null(srtList) & is.null(srtMerge)) {
    stop("srtList and srtMerge were all empty.")
  }
  if (!is.null(srtList) & !is.null(srtMerge)) {
    cell1 <- lapply(srtList, colnames) %>%
      unlist() %>%
      unique() %>%
      sort()
    cell2 <- colnames(srtMerge) %>%
      unique() %>%
      sort()
    if (!identical(cell1, cell2)) {
      stop("srtList and srtMerge have different cells.")
    }
  }
  if (isTRUE(append)) {
    if (is.null(srtMerge)) {
      stop("srtMerge must be provided when 'append = TRUE'.")
    } else {
      srtMerge_raw <- srtMerge
    }
  }
  if (!is.null(srtList)) {
    checked <- Check_srtList(srtList,
      normalization_method = normalization_method,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = exogenous_genes
    )
    srtList <- checked[["srtList"]]
    hvf <- checked[["hvf"]]
    srtMerge <- Reduce(function(x, y) merge(x, y), srtList)
    VariableFeatures(srtMerge) <- hvf
  }
  if (is.null(srtList) & !is.null(srtMerge)) {
    checked <- Check_srtMerge(srtMerge,
      normalization_method = normalization_method, batch = batch,
      HVF_source = HVF_source, nHVF = nHVF, hvf = hvf,
      exogenous_genes = NULL
    )
    srtMerge <- checked[["srtMerge"]]
    hvf <- checked[["hvf"]]
  }

  sce <- as.SingleCellExperiment(srtMerge)
  assay(sce, "counts") <- as(counts(sce), "matrix")
  if (ncol(sce) < 10000) {
    sce_zinbwave <- zinbwave(
      Y = sce,
      K = 2,
      X = paste0("~", batch),
      which_assay = "counts",
      which_genes = hvf,
      epsilon = length(hvf),
      normalizedValues = TRUE,
      residuals = TRUE,
      BPPARAM = MulticoreParam()
    )
  } else {
    state <- 1
    while (state != 0) {
      tryCatch(expr = {
        sce_zinbwave <- zinbsurf(
          Y = sce,
          K = 2,
          X = paste0("~", batch),
          which_assay = "counts",
          which_genes = hvf,
          epsilon = length(hvf),
          prop_fit = 0.2,
          BPPARAM = MulticoreParam(workers = 8)
        )
        state <- 0
      }, error = function(error) {
        message(error)
        cat("Resampling the cells for zinbsurf ......\n")
        state <- state + 1
        if (state > 5) {
          stop("Resampling too many times. Stop the integration.\n")
        }
      })
    }
  }

  srtIntegrated <- as.Seurat(
    x = sce_zinbwave,
    counts = "counts",
    assay = "ZINBWaVE"
  )
  srtIntegrated@assays$RNA <- srtMerge@assays$RNA
  DefaultAssay(srtIntegrated) <- "ZINBWaVE"
  sce_zinbwave <- sce <- NULL

  srtIntegrated <- Check_srtIntegrated(srtIntegrated, hvf = hvf, batch = batch)

  srtIntegrated <- NormalizeData(object = srtIntegrated, normalization.method = "LogNormalize")
  srtIntegrated <- ScaleData(srtIntegrated, features = hvf)
  srtIntegrated <- RunPCA(
    object = srtIntegrated, npcs = maxPC, features = hvf,
    reduction.name = paste0(reduction_prefix, "pca"),
    reduction.key = paste0(reduction_prefix, "pca_")
  )
  dims <- 1:ceiling(maxLikGlobalDimEst(data = Embeddings(srtIntegrated, reduction = paste0(reduction_prefix, "pca")), k = 20, iterations = 100)[["dim.est"]])
  srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]] <- dims

  srtIntegrated <- FindNeighbors(object = srtIntegrated, reduction = paste0(reduction_prefix, "pca"), dims = dims, force.recalc = T)
  srtIntegrated <- FindClusters(object = srtIntegrated, resolution = resolution, algorithm = 1, n.start = 100, n.iter = 10000)
  if (isTRUE(reorder)) {
    srtIntegrated <- SrtReorder(srtIntegrated, features = hvf, reorder_by = "seurat_clusters", slot = "data")
  }
  srtIntegrated[[paste0(reduction_prefix, "clusters")]] <- Idents(srtIntegrated)

  for (n in reduction_components) {
    if ("umap" %in% reduction) {
      srtIntegrated <- RunUMAP(
        object = srtIntegrated, reduction = paste0(reduction_prefix, "pca"),
        reduction.name = paste0(reduction_prefix, "UMAP", n, "d"),
        reduction.key = paste0(reduction_prefix, "UMAP", n, "d_"),
        dims = dims, n.components = n, umap.method = "uwot",
        return.model = TRUE, verbose = TRUE
      )
    }
    if ("tsne" %in% reduction) {
      srtIntegrated <- RunTSNE(
        object = srtIntegrated, reduction = paste0(reduction_prefix, "pca"),
        reduction.name = paste0(reduction_prefix, "TSNE", n, "d"),
        reduction.key = paste0(reduction_prefix, "TSNE", n, "d_"),
        dims = dims, dim.embed = n, tsne.method = "Rtsne",
        perplexity = max(ceiling(ncol(srtIntegrated) * 0.01), 30), max_iter = 2000,
        num_threads = 0, verbose = TRUE
      )
    }
  }

  DefaultAssay(srtIntegrated) <- "RNA"
  if (isTRUE(append)) {
    DefaultAssay(srtMerge_raw) <- "RNA"
    srtMerge_raw@assays$ZINBWaVE <- srtIntegrated@assays$ZINBWaVE
    srtMerge_raw[[paste0(reduction_prefix, "pca")]] <- srtIntegrated[[paste0(reduction_prefix, "pca")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "Dims")]] <- srtIntegrated@misc[[paste0(reduction_prefix, "Dims")]]
    srtMerge_raw@misc[[paste0(reduction_prefix, "HVF")]] <- hvf
    srtMerge_raw[[paste0(reduction_prefix, "clusters")]] <- srtIntegrated[[paste0(reduction_prefix, "clusters")]]
    for (n in reduction_components) {
      for (i in reduction) {
        srtMerge_raw[[paste0(reduction_prefix, toupper(i), n, "d")]] <- srtIntegrated[[paste0(reduction_prefix, toupper(i), n, "d")]]
      }
    }
    return(srtMerge_raw)
  } else {
    return(srtIntegrated)
  }
}


DEtest <- function(srt, FindAllMarkers = TRUE, FindPairMarkers = TRUE,
                   foldchange_threshold = 1.5, pvalue_threshold = 0.05, roc_threshold = 0.4,
                   BPPARAM = MulticoreParam(), ...) {
  if (isTRUE(FindAllMarkers)) {
    DefaultAssay(srt) <- "RNA"
    AllMarkers_Wilcoxon <- FindAllMarkers(
      object = srt, only.pos = T, logfc.threshold = log2(foldchange),
      test.use = "wilcox", return.thresh = pvalue_threshold # , latent.vars = "orig.ident"
    )
    AllMarkers_ROC <- FindAllMarkers(
      object = srt, only.pos = T, logfc.threshold = log2(foldchange),
      test.use = "roc", return.thresh = roc_threshold
    )
    srt@tools$FindAllMarkers <- setNames(
      object = list(AllMarkers_Wilcoxon, AllMarkers_ROC),
      nm = c("AllMarkers_Wilcoxon", "AllMarkers_ROC")
    )
  }

  if (isTRUE(FindPairMarkers)) {
    DefaultAssay(srt) <- "RNA"
    pair <- expand.grid(x = levels(Idents(srt)), y = levels(Idents(srt)))
    pair <- pair[pair[, 1] != pair[, 2], ]
    PairMarkers_Wilcoxon <- bplapply(1:nrow(pair), function(i) {
      res <- FindMarkers(
        ident.1 = as.character(pair[i, 1]), ident.2 = as.character(pair[i, 2]),
        object = srt, only.pos = T, logfc.threshold = log2(foldchange),
        test.use = "wilcox" # , latent.vars = "orig.ident"
      )
      res[, "ident.1"] <- as.character(pair[i, 1])
      res[, "ident.2"] <- as.character(pair[i, 2])
      res[, "gene"] <- rownames(res)
      res <- res[res[["p_val"]] < pvalue_threshold, ]

      return(res)
    }, BPPARAM = BPPARAM)
    PairMarkers_Wilcoxon <- bind_rows(PairMarkers_Wilcoxon)
    PairMarkers_Wilcoxon[, "DEnumber"] <- table(PairMarkers_Wilcoxon[["gene"]])

    srt@tools$FindPairMarkers <- setNames(
      object = PairMarkers_Wilcoxon,
      nm = "PairMarkers_Wilcoxon"
    )

    # exp1<- GetAssayData(object = srt,assay = "RNA",slot = "data")["NEUROD1",WhichCells(srt,idents = as.character(pair[1,1]))]
    # exp2<- GetAssayData(object = srt,assay = "RNA",slot = "data")["NEUROD1",WhichCells(srt,idents = as.character(pair[2,1]))]
    # sum(exp1!=0)/length(exp1)
    # sum(exp2!=0)/length(exp2)
    # log2(mean(exp(exp1))/mean(exp(exp2)))
  }

  return(srt)
}

Standard_SCP <- function(srt, normalization_method = "logCPM", nHVF = 3000, hvf = NULL,
                         maxPC = 100, resolution = 0.8, reorder = TRUE,
                         reduction = "umap", reduction_prefix = "",
                         exogenous_genes = NULL) {
  require(glmGamPoi)
  require(intrinsicDimension)

  if (class(srt) != "Seurat") {
    stop("'srt' is not a Seurat object.",
      call. = FALSE
    )
  }
  if (!normalization_method %in% c("logCPM", "SCT")) {
    stop("'normalization_method' must be one of: 'logCPM','SCT'",
      call. = FALSE
    )
  }

  DefaultAssay(srt) <- "RNA"

  if (identical(
    x = GetAssayData(srt, slot = "counts"),
    y = GetAssayData(srt, slot = "data")
  )) {
    srt <- NormalizeData(object = srt, normalization.method = "LogNormalize")
  }
  if (is.null(hvf)) {
    if (!"vst.variance.standardized" %in% colnames(srt@assays$RNA@meta.features)) {
      srt <- FindVariableFeatures(srt)
    }
    m <- GetAssayData(srt, slot = "counts")
    gene_keep <- rownames(m)[Matrix::rowSums(m >= 1) >= 5]
    VariableFeatures(srt) <- hvf <- srt@assays$RNA@meta.features %>%
      filter(vst.variance.standardized > 1 &
        (!rownames(.) %in% exogenous_genes) &
        rownames(.) %in% gene_keep) %>%
      dplyr::arrange(desc(vst.variance.standardized)) %>%
      rownames(.) %>%
      head(n = nHVF)
  } else {
    hvf <- hvf[hvf %in% rownames(GetAssayData(srt, slot = "counts"))]
    VariableFeatures(srt) <- hvf
  }
  if (nrow(GetAssayData(srt, slot = "scale.data")) != nrow(GetAssayData(srt, slot = "data"))) {
    srt <- Seurat::ScaleData(object = srt, features = rownames(srt))
  }
  DefaultAssay(srt) <- "RNA"

  if (normalization_method %in% c("SCT")) {
    if (!"SCT" %in% Seurat::Assays(srt)) {
      srt <- SCTransform(
        object = srt,
        method = "glmGamPoi",
        variable.features.n = nHVF,
        return.only.var.genes = FALSE,
        min_cells = 5,
        assay = "RNA"
      )
    }
    DefaultAssay(srt) <- "SCT"
    if (is.null(hvf)) {
      if (!"residual_variance" %in% colnames(srt@assays$SCT@meta.features)) {
        feature.attr <- SCTResults(object = srt, slot = "feature.attributes")
        nfeatures <- min(nHVF, nrow(x = feature.attr))
        top.features <- rownames(x = feature.attr)[order(feature.attr$residual_variance,
          decreasing = TRUE
        )[1:nHVF]]
        VariableFeatures(object = srt) <- top.features
        srt@assays$SCT@meta.features <- feature.attr
      }
      m <- GetAssayData(srt, slot = "counts")
      gene_keep <- rownames(m)[Matrix::rowSums(m >= 1) >= 5]
      VariableFeatures(srt) <- hvf <- srt@assays$SCT@meta.features %>%
        filter((!rownames(.) %in% exogenous_genes) &
          rownames(.) %in% gene_keep) %>%
        dplyr::arrange(desc(residual_variance)) %>%
        rownames(.) %>%
        head(n = nHVF)
    } else {
      hvf <- hvf[hvf %in% rownames(GetAssayData(srt, slot = "counts"))]
      VariableFeatures(srt) <- hvf
    }
  }

  srt <- RunPCA(
    object = srt, npcs = maxPC, features = hvf,
    reduction.name = paste0(reduction_prefix, "pca"),
    reduction.key = paste0(reduction_prefix, "pca_")
  )
  dim_est <- maxLikGlobalDimEst(data = Embeddings(srt, reduction = paste0(reduction_prefix, "pca")), k = 20, iterations = 100)[["dim.est"]]
  if (!is.na(dim_est)) {
    dims <- 1:ceiling(dim_est)
  } else {
    dims <- 1:20
  }
  srt@misc[[paste0(reduction_prefix, "Dims")]] <- dims

  srt <- FindNeighbors(object = srt, reduction = paste0(reduction_prefix, "pca"), dims = dims, force.recalc = T)
  srt <- FindClusters(object = srt, resolution = resolution, algorithm = 1, n.start = 100, n.iter = 10000)
  if (isTRUE(reorder)) {
    srt <- SrtReorder(srt, features = hvf, reorder_by = "seurat_clusters", slot = "data")
  }
  srt[[paste0(reduction_prefix, "clusters")]] <- Idents(srt)

  for (n in reduction_components) {
    if ("umap" %in% reduction) {
      srt <- RunUMAP(
        object = srt, reduction = paste0(reduction_prefix, "pca"),
        reduction.name = paste0(reduction_prefix, "UMAP", n, "d"),
        reduction.key = paste0(reduction_prefix, "UMAP", n, "d_"),
        dims = dims, n.components = n, umap.method = "uwot",
        return.model = TRUE, verbose = TRUE
      )
    }
    if ("tsne" %in% reduction) {
      srt <- RunTSNE(
        object = srt, reduction = paste0(reduction_prefix, "pca"),
        reduction.name = paste0(reduction_prefix, "TSNE", n, "d"),
        reduction.key = paste0(reduction_prefix, "TSNE", n, "d_"),
        dims = dims, dim.embed = n, tsne.method = "Rtsne",
        perplexity = max(ceiling(ncol(srt) * 0.01), 30), max_iter = 2000,
        num_threads = 0, verbose = TRUE
      )
    }
  }

  DefaultAssay(srt) <- "RNA"
  return(srt)
}

Integration_SCP <- function(srtList = NULL, srtMerge = NULL, append = FALSE,
                            integration_method = "Uncorrected", batch = "orig.ident",
                            normalization_method = "logCPM",
                            HVF_source = "separate", nHVF = 3000, hvf = NULL,
                            maxPC = 100, resolution = 0.8, reorder = TRUE, reduction = "umap",
                            exogenous_genes = NULL, ...) {
  if (is.null(srtList) & is.null(srtMerge)) {
    stop("srtList and srtMerge were all empty.")
  }
  if (length(integration_method) == 1 & integration_method %in% c("Uncorrected", "Seurat", "fastMNN", "Harmony", "Scanorama", "BBKNN", "CSS", "LIGER")) {
    args1 <- c(mget(names(formals())), reduction_prefix = integration_method)
    args2 <- c(as.list(match.call()), reduction_prefix = integration_method)
    for (n in names(args2)) {
      args1[[n]] <- args2[[n]]
    }
    tryCatch(expr = {
      srtIntegrated <- base::do.call(
        what = paste0(integration_method, "_integrate"),
        args = args1
      )
    }, error = function(e) {
      message(e)
      message(cat("\n", paste0("[", Sys.time(), "]", " Stop the integration...\n")))
      stop(call. = FALSE)
    })
    if (exists("srtIntegrated")) {
      return(srtIntegrated)
    }
    if (!is.null(srtMerge)) {
      return(srtMerge)
    }
    return(NULL)
  } else {
    stop(paste(integration_method, "is not a suppoted integration method!"),
      call. = FALSE
    )
  }
}
